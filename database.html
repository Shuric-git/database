----------------
Оптимизация кода.
----------------
Управляй зависимостями.
Не стоит использовать сторонние библиотеки там где в этом нет крайней необходимости. Стоит следить за весом этих библиотек. Необходимо чистить код от устаревшего, неиспользуемого кода
и обращать внимание не стала ли та или иная фича приложения рудиментарной и нельзя ли от ней избавиться или изменить логику работы с ней.

Кеширование данных. 
Например через JS API Cache . 
Принцип работы заключается в сохранении ответов на запросы в Cache хранилище, откуда по запросу можно
закешированные данные достать и обработать, не делая повторного запроса к серверу. RTK Query подобные манипуляции производит автоматически.
Кеширование браузером.
Возможно прописать заголовок Expires и позволить браузеру кешировать компоненты сайта. Таким образом при повторном подключении клиента некоторые элемены не придётся грузить заново. 

Экономь память.
Не стоит забывать освобождать память там где это возможно, отключать слушатели, избегать memory leak. Частое использование сборщика мусора также может негативно сказаться на производительности.

Используй отложенную загрузку скриптов.
Самый первоочерёдный вариант, конечно, defer и async, но также можно индивидуально задерживать скрипты по таймауту и использовать динамические скрипты.
Defer - откладывает загрузку скриптов на этап после отрисовки dom дерева (но до события DOMContentLoaded), но сохраняет поточность загрузки самх скриптов. 
Вне зависимости от размера скрипта, первым будет загружен тот, который раньше попадается в потоке.
Async - делает загрузку скрипта(ов) полностью асинхронной. DOM дерево загружается независимо от них и сами скрипты ни от чего не зависят и ничего не ждут. Первыми загрузятся
скрипты меньшего размера. Небольшие скрипты могут загрузиться раньше чем будет отрисована страница.
Динамические скрипты грузятся по правилам async.

Используй Web Workers. (крайне специфичный кейс)
Для ресурсоёмких вычислений можно использовать Web Workers. Веб воркеры могут выполнять почти любой код в собственном потоке и возвращать результат вычислений с помощью системы сообщений.

Сохранение ссылки на DOM элемент в переменную.
Создание ссылки на дом дерево - дорогостоящая операция. Если необходимо несколько раз использовать эту ссылку, то стоит её сохранить в переменную, а не создавать заново. Но стоит помнить, 
что если позже этот элемент будет удалён, то и ссылку нужно будет удалить из переменной (например переопределив её на null). 

Уменьшай количество HTTP запросов.
Большое количество запросов может заметно замедлить работу приложения. Стоит рационально подходить к этому вопросу. 
Использование RTK Query упрощает этот процесс. Данные при запросе кешируются 
и при повторяющихся запросах используются сохраненные данные (если данные всё же нужно обновлять ставим инвалидацию тегов). 
Также можно уменьшить количество запросов за счёт использования css спрайта. Методика при которой мы используем одно комбинированное изображение части которого средствами css подставляются
в различные области страницы.

Используй поддомены.
Спецификация протокола HTTP 1.1 не позволяет загружать одновременно больше двух компонентов сайта с одного хоста. Возможно разделить загрузку между поддоменами. Для нас это будет одним и тем же сервером,
а для браузера - разными. Таким образом можно распараллелить загрузку.

Используй сжатие (Gzip, Brotli)
Очевидно что файлы меньшего размера проще транспортировать. Для того что бы воспользоваться преимуществами сжатия нужно использовать заголовок Accept-Encoding: gzip, deflate,
получая запрос с таким заголовком сервер применяет сжатие ответа одним из указанным в заголовке методом. Также сервер уведомляет клиент о типе сжатия: Content-Encoding: gzip.
Стоит учитывать, правда, что сжатие увеличивает нагрузку на сервер. Также для включения сжатия на сайте необходимо внести соответствующие изменения в файл .htaccess. 

Используй code-splitting. 
Это разделение итогового бандла на логические блоки. Обеспечивается сборщиками. В случае с Реактом и некоторыми другими библиотеками и фреймворками может работать из коробки, 
в остальных нужно поднастроить сам сборщик. Разделяя итоговый бандл на несколько файлов можно организовать постепенную подгрузку файлов. Например через lazy-load, динамический импорт. 
Также хорошо сочетается с React Router. 

Используй tree-shaking. 
Метод оптимизации при котором весь фактически не использованный код будет исключён из финального бандла. В случае с Webpack, tree-shaking является частью режима продакшена (mode: production). 
Но стоит помнить что, во-первых, tree-shaking работает только со статическим импортом (import - да, require - нет), и что не все наши фаункции и утилиты экспортируются, а значит защищены
от сбрасывания с веток. Но они, конечно, могут быть защищены средствами Webpack 
{
    ...,
    "sideEffects": [
        "./src/polyfill.js"
    ],
    ...,
}

Минифицируй файлы.
Минификация достигается средствами сборщиков. Конкретно, уже внутри обработки сборщиком, как пример, за это отвечает компилятор-транспилятор babel. 

Изображения

Оптимизируй изображения.
Ну тут всё понятно. Уменьшай, если можно уменьшить. Используй тег "picture". Масштабирование средствами css также негативно сказывается на производительности.
Всему своё место: jpeg - основное преимущество - степень сжатия, png - наличие альфа-канала, svg (Scalable Vector Graphics) - суперзвезда, векторное изображение
WebP - достаточно прогрессивный формат, который сочетает высокую степень сжатия и наличие маски альфа-канала.

Используй lazy-load (ленивую загрузку) - фоновую подгрузку изображений по условиям. 

Грузи изображения через CDN (распределённую систему доставки изображений (Content Delivery Network))

CSS preload. 
Методика подгрузки некоторой части стилей вперёд остальных, улучшает скорее пользовательский опыт, но может и ускорить подгрузку.

----------------------------------------------
Анализ производительности (какие есть метрики)
----------------------------------------------

Вероятно стоит упомянуть что достаточно очевидные события DOMContentLoaded (страница загружена, но скрипты только начинают отрабатывать) и load (когда загрузилась страница и поьзователь может 
полностью с ней взаимодействовать) являются слишком обобщёнными и не дают достаточной информации для использования в целях оптимизации.

Рассмотрим некоторые метрики из группы PWM (Progressive Web Metrics от Google)

Первая отрисовка (First paint)
Это буквально белый лист, когда никакой контент ещё не начал отрисовываться и есть только некоторый фоновый слой. Фактически Первая отрисовка не является частью PWM, являясь скорее некой отправной
точкой начала отрисовки. Понимание процесса работы графического слоя поможет в принципе разобраться с метриками.

Первая отрисовка контента (First Contentful Pain)

