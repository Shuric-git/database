----------------
Оптимизация кода.
----------------
Управляй зависимостями.
Не стоит использовать сторонние библиотеки там где в этом нет крайней необходимости. Стоит следить за весом этих библиотек. Необходимо чистить код от устаревшего, неиспользуемого кода
и обращать внимание не стала ли та или иная фича приложения рудиментарной и нельзя ли от ней избавиться или изменить логику работы с ней.

Кеширование данных. 
Например через JS API Cache . 
Принцип работы заключается в сохранении ответов на запросы в Cache хранилище, откуда по запросу можно
закешированные данные достать и обработать, не делая повторного запроса к серверу. RTK Query подобные манипуляции производит автоматически.
Кеширование браузером.
Возможно прописать заголовок Expires и позволить браузеру кешировать компоненты сайта. Таким образом при повторном подключении клиента некоторые элемены не придётся грузить заново. 

Экономь память.
Не стоит забывать освобождать память там где это возможно, отключать слушатели, избегать memory leak. Частое использование сборщика мусора также может негативно сказаться на производительности.

Используй отложенную загрузку скриптов.
Самый первоочерёдный вариант, конечно, defer и async, но также можно индивидуально задерживать скрипты по таймауту и использовать динамические скрипты.
Defer - откладывает загрузку скриптов на этап после отрисовки dom дерева (но до события DOMContentLoaded), но сохраняет поточность загрузки самх скриптов. 
Вне зависимости от размера скрипта, первым будет загружен тот, который раньше попадается в потоке.
Async - делает загрузку скрипта(ов) полностью асинхронной. DOM дерево загружается независимо от них и сами скрипты ни от чего не зависят и ничего не ждут. Первыми загрузятся
скрипты меньшего размера. Небольшие скрипты могут загрузиться раньше чем будет отрисована страница.
Динамические скрипты грузятся по правилам async.

Используй Web Workers. (крайне специфичный кейс)
Для ресурсоёмких вычислений можно использовать Web Workers. Веб воркеры могут выполнять почти любой код в собственном потоке и возвращать результат вычислений с помощью системы сообщений.

Сохранение ссылки на DOM элемент в переменную.
Создание ссылки на дом дерево - дорогостоящая операция. Если необходимо несколько раз использовать эту ссылку, то стоит её сохранить в переменную, а не создавать заново. Но стоит помнить, 
что если позже этот элемент будет удалён, то и ссылку нужно будет удалить из переменной (например переопределив её на null). 

Уменьшай количество HTTP запросов.
Большое количество запросов может заметно замедлить работу приложения. Стоит рационально подходить к этому вопросу. 
Использование RTK Query упрощает этот процесс. Данные при запросе кешируются 
и при повторяющихся запросах используются сохраненные данные (если данные всё же нужно обновлять ставим инвалидацию тегов). 
Также можно уменьшить количество запросов за счёт использования css спрайта. Методика при которой мы используем одно комбинированное изображение части которого средствами css подставляются
в различные области страницы.

Используй поддомены.
Спецификация протокола HTTP 1.1 не позволяет загружать одновременно больше двух компонентов сайта с одного хоста. Возможно разделить загрузку между поддоменами. Для нас это будет одним и тем же сервером,
а для браузера - разными. Таким образом можно распараллелить загрузку.

Используй сжатие (Gzip, Brotli)
Очевидно что файлы меньшего размера проще транспортировать. Для того что бы воспользоваться преимуществами сжатия нужно использовать заголовок Accept-Encoding: gzip, deflate,
получая запрос с таким заголовком сервер применяет сжатие ответа одним из указанным в заголовке методом. Также сервер уведомляет клиент о типе сжатия: Content-Encoding: gzip.
Стоит учитывать, правда, что сжатие увеличивает нагрузку на сервер. Также для включения сжатия на сайте необходимо внести соответствующие изменения в файл .htaccess. 

Используй code-splitting. 
Это разделение итогового бандла на логические блоки. Обеспечивается сборщиками. В случае с Реактом и некоторыми другими библиотеками и фреймворками может работать из коробки, 
в остальных нужно поднастроить сам сборщик. Разделяя итоговый бандл на несколько файлов можно организовать постепенную подгрузку файлов. Например через lazy-load, динамический импорт. 
Также хорошо сочетается с React Router. 

Используй tree-shaking. 
Метод оптимизации при котором весь фактически не использованный код будет исключён из финального бандла. В случае с Webpack, tree-shaking является частью режима продакшена (mode: production). 
Но стоит помнить что, во-первых, tree-shaking работает только со статическим импортом (import - да, require - нет), и что не все наши фаункции и утилиты экспортируются, а значит защищены
от сбрасывания с веток. Но они, конечно, могут быть защищены средствами Webpack 
{
    ...,
    "sideEffects": [
        "./src/polyfill.js"
    ],
    ...,
}

Минифицируй файлы.
Минификация достигается средствами сборщиков. Конкретно, уже внутри обработки сборщиком, как пример, за это отвечает компилятор-транспилятор babel. 

Изображения

Оптимизируй изображения.
Ну тут всё понятно. Уменьшай, если можно уменьшить. Используй тег "picture". Масштабирование средствами css также негативно сказывается на производительности.
Всему своё место: jpeg - основное преимущество - степень сжатия, png - наличие альфа-канала, svg (Scalable Vector Graphics) - суперзвезда, векторное изображение
WebP - достаточно прогрессивный формат, который сочетает высокую степень сжатия и наличие маски альфа-канала.

Используй lazy-load (ленивую загрузку) - фоновую подгрузку изображений по условиям. 

Грузи изображения через CDN (распределённую систему доставки изображений (Content Delivery Network))

CSS preload. 
Методика подгрузки некоторой части стилей вперёд остальных, улучшает скорее пользовательский опыт, но может и ускорить подгрузку.

----------------------------------------------
Анализ производительности (какие есть метрики)
----------------------------------------------

Вероятно стоит упомянуть что достаточно очевидные события DOMContentLoaded (страница загружена, но скрипты только начинают отрабатывать) и load (когда загрузилась страница и поьзователь может 
полностью с ней взаимодействовать) являются слишком обобщёнными и не дают достаточной информации для использования в целях оптимизации.

Если рисовать широкими мазками, то в качестве ключевых метрик можно выделить:

Скорость загрузки
Отзывчивость (или интерактивность)

Далее метрики могут немного отличаться, хотя суть остаётся прежней - они отражают различные этабы загрузки приложения. 

Согласно Google Web Vitals выделяются:

LCP (Largest Contentful Paint)

Загрузка основного, самого объёмного по весу содержимого страницы. По данным Google LCP не должен премышать 2.5 секунд. 

На LCP напрямую влияют:
+ Время отклика сервера
+ Блокировка отрисовки CSS и/или JS
+ Отрисовка Клиентом
+ Долгое время загрузки ресурса

FID (First Input Delay)

Эта метрика отвечает за интерактивность приложения и выражается во времени с момента, когда пользователь начал взаимодействие с интерактивными элементами, до момента,
когда сервер реально был готов ответить на взаимодействие. Для позитивного UX необходимо держать FCP меньше 100 мс. 

На FID влияют
+ Долгий ответ сервера
+ Большие бандлы 
+ Длительное исполнение JS
+ Блокирующий отрисовку JS

Но стоит учитывать, что проверить FID можно только в полевых условиях, на этапе разработки можно измерять 
TBT (Total Blocking Time)

Эта метрика отражает время блокировки основного потока выполнения какой-то задачей. Для позитивного UX TBT не должен превышать 50 мс.

CLS (Cumulative Layout Shift)

Метрика измеряет стабильность макета или визуальную стабильность страницы

Показывает какое количество содержимогово Viewport двигалось во время загрузки страницы. С её помощью можно убедиться, что взаимодействие с сайтом плавное и естественное. 
На CLS влияют: 
+ Картинки без размеров
+ IFrame без размеров 
+ Динамически добавленный контент 
+ Шрифты вызывают FOIT/FOUT (мерцание невидимых или нестилизованных шрифтов)

Что бы компенсировать негативное влияние CLS необходимо резервировать место под динамически добавляемый контент. 

Рассмотрим некоторые метрики из группы PWM (Progressive Web Metrics от Google)

Первая отрисовка (First paint)
Это буквально белый лист, когда никакой контент ещё не начал отрисовываться и есть только некоторый фоновый слой. Фактически Первая отрисовка не является частью PWM, являясь скорее некой отправной
точкой начала отрисовки. Понимание процесса работы графического слоя поможет в принципе разобраться с метриками.

Первая отрисовка контента (First Contentful Paint)

Буквально - первый отрисованный контент. Это может быть текст, менюшка, картинка, что угодно.

Если есть проблемы на данном этапе, это явное указание того, что контент чрезмерно тяжёлый либо есть проблемы соединения.

Первая значимая отрисовка (First Meaningful Paint)

Это уже моментт, когда на странице появился весь основной контент. Когда пользователь может уже уверенно для себя определить "это то что мне нужно?", попал ли он на правильный для себя ресурс. 
Есть вполне конкретные элементы относимые или не к значимому контенту. 

К значимому, например, относятся:
+ Шапка сайта
+ Картинки каталога (если речь об интернет-магазине)
+ Текст блога
+ Содержимое для поисковиков

Не относятся к значимому контенту: 
- Спиннеры, прелоадеры
- FOUC
- Невидимый текст
- Только навигация

Визуально готов (Visually Ready)

Этап, когда отрисовка фактически завершена, но скрипты ещё продолжают работу. 

Задержка ввода (Estimated Input Latency)

Метрика, которая показывает насколько задачи приложения негативно влияют на интерфейсные задачи. 

Первое взаимодействие (First Interactive)

Есть конкретные условия которым должна отвечать страница, готовая к взаимодействию:
+ Завершена первая значимая отрисовка
+ Отработал DOMContentLoaded
+ Страница визуально готова на 85%

Также метрика первого взаимодействия дробится ещё на две метрики 

1. Время до первого взаимодействия (TTFI)
2. Время до первого последовательного взаимодействия (TTFI)

+ За счёт такого дробления можно определить момент, когда интерфейс уже может отвечать, но ещё есть некоторые задержки
+ Когда интерфейс полностью функционален и строго отвечает требованиям RAIL

Визуально готово (Visually Complete)

GraphQL

Это язык запросов, котороый позволяет клиенту делать запросы к базе данных. 
Основные преимущества GraphQL

+ Запросы конкретных данных, которые нужны клиенту
+ Упрощение агрегации данных из нескольких источников
+ Использование системы типов для описания данных 