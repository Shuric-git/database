Оптимизация кода.
Не стоит использовать сторонние библиотеки там где в этом нет крайней необходимости. Стоит следить за весом этих библиотек. Необходимо чистить код от устаревшего, неиспользуемого кода
и обращать внимание не стала ли та или иная фича приложения рудиментарной и нельзя ли от ней избавиться или изменить логику работы с ней.

Кеширование данных через JS API Cache. 
Принцип работы заключается в сохранении ответов на запросы в Cache хранилище, откуда по запросу можно
закешированные данные достать и обработать, не делая повторного запроса к серверу. RTK Query подобные манипуляции производит автоматически.

Экономь память.
Не стоит забывать освобождать память там где это возможно, отключать случатели, избегать memory leak. Частое использование сборщика мусора также может негативно сказаться на производительности.

Используй отложенную загрузку скриптов.
Самый первоочерёдный вариант, конечно, defer и async, но также можно индивидуально задерживать скрипты по таймауту и динамические скрипты.
Defer - откладывает загрузку скриптов на этап после отрисовки dom дерева (но до события DOMContentLoaded), но сохраняет поточность загрузки самх скриптов. 
Вне зависимости от размера скрипта, первым будет загружен тот, который раньше попадается в потоке.
Async - делает загрузку скрипта(ов) полностью асинхронной. DOM дерево загружается независимо от них и сами скрипты ни от чего не зависят и ничего не ждут. Первыми загрузятся
скрипты меньшего размера. Небольшие скрипты могут загрузиться раньше чем будет отрисована страница.
Динамические скрипты грузятся по правилам async.

Используй Web Workers. (крайне специфичный кейс)
Для ресурсоёмких вычислений можно использовать Web Workers. Веб воркеры могут выполнять почти любой код в собственном потоке и возвращать результат вычислений с помощью системы сообщений.

Сохранение ссылки на DOM элемент в переменную.
Создание ссылки на дом дерево - дорогостоящая операция. Если необходимо несколько раз использовать эту ссылку, то стоит её сохранить в переменную, а не создавать заново. Но стоит помнить, 
что если позже этот элемент будет удалён, то и ссылку нужно будет удалить из переменной (например переопределив её на null). 

Уменьшай количество HTTP запросов.
Большое количество запросов может заметно замедлить работу приложения. Стоит рационально подходить к этому вопросу. 
Использование RTK Query упрощает этот процесс. Данные при запросе кешируются 
и при повторяющихся запросах используются сохраненные данные (если данные всё же нужно обновлять ставим инвалидацию тегов). 
Также можно уменьшить количество запросов за счёт использования css спрайта. Методика при которой мы используем одно комбинированное изображение части которого средствами css подставляются
в различные области страницы.

Минифицируй файлы.
Минификация достигается средствами сборщиков. Конкретно, как пример, за это отвечает babel. 

Используй поддомены.
Спецификация протокола HTTP 1.1 не позволяет загружать одновременно больше двух компонентов сайта с одного хоста. Возможно разделить загрузку между поддоменами. Для нас это будет одним и тем же сервером,
а для браузера - разными. Таким образом можно распараллелить загрузку.

Кеширование браузером.
Возможно прописать заголовок Expires и позволить браузеру кешировать компоненты сайта. Таким образом при повторном подключении клиента некоторые элемены не придётся грузить заново. 

Оптимизируй изображения.
Ну тут всё понятно. Уменьшай, если можно уменьшить. Используй тег <picture>